#include <windows.h>#include <GL/glut.h>#include <iostream>#include <math.h>#include <string>#include <fstream>using namespace std;struct Point{ float x; float y;};Point top_left = {.x=0, .y=600};Point top_right = {.x=1000, .y=600};Point bottom_left = {.x=0, .y=0};Point bottom_right = {.x=1000, .y=0};Point top_gap = {.x=0, .y=70};Point bottom_gap = {.x=0, .y=10};struct State{ int start; int play; int running; int pause; int over; int level; int complete;};State state = {.start=1,.play=2,.running=3,.pause=4,.over=5,.level=6,.complete=7};int cstate = state.start;struct Color{float r;float g;float b;float a;};Color background_color = {.r=1,.g=1,.b=1,.a=1};Color top_gap_color = {.r=1,.g=0,.b=0,.a=1};Color top_text_color = {.r=1,.g=1,.b=1,.a=1};Color state_background_color = {.r=0,.g=0,.b=0,.a=0.9};int high_score;float time;int level;int score;float displayRate = 1000/60;const double PI = atan(1) * 4;void updateScore(){    score = score + (int)(1000/((time*100)+1));}void getHighScore(){    ifstream inFile;    inFile.open("high_score.txt");    if(inFile){        inFile>>high_score;    }else{        high_score = 0;    }    inFile.close();}void setHighScore(){    ofstream outFile;    outFile.open("high_score.txt");    outFile<<score<<endl;    outFile.close();}void updateLevel(){    if(level<4){        level++;        cstate = state.level;    }else{        cstate = state.complete;    }}class Bar{    public:        Point bar_size;        float position_left;        float position_right;        float position_bottom;        float position_top;        Color color = {.r=1,.g=0,.b=0,.a=1};        Bar(){};        Bar(int x,int y){            bar_size.x = x;            bar_size.y = y;            position_left = (bottom_right.x/2)-(bar_size.x/2);            position_right = position_left+bar_size.x;            position_bottom = bottom_left.y+bottom_gap.y;            position_top = bottom_left.y+bottom_gap.y+bar_size.y;        }        void draw(){            glBegin(GL_POLYGON);                glColor4f(color.r,color.g,color.b,color.a);                glVertex2f(position_left, position_bottom);                glVertex2f(position_right, position_bottom);                glVertex2f(position_right, position_top);                glVertex2f(position_left, position_top);            glEnd();        }        void update(int x){            float new_left = x-(bar_size.x/2);            float new_right = x+(bar_size.x/2);            if(new_left>=bottom_left.x && new_right<=bottom_right.x){                position_left = new_left;                position_right = new_right;            }        }};Bar bar;class Ball{    public:        float cx;        float cy;        float r;        float speed;        float angle;        Point direction;        Color color = {.r=1,.g=0,.b=0,.a=1};        Ball(){};        Ball(int rr){            cx = 500;            cy = bottom_gap.y+bar.bar_size.y+rr;            r = rr;            speed = 5;            angle = 20;            direction.x = -1;            direction.y = 1;        }        void draw(){            int triangleAmount = 100;            glBegin(GL_TRIANGLE_FAN);                glColor4f(color.r,color.g,color.b,color.a);                glVertex2f(cx, cy);                for(int i = 0; i <= triangleAmount;i++){                    float theta = i *  2 * PI / triangleAmount;                    glVertex2f(                        cx + (r * cos(theta)),                        cy + (r * sin(theta))                    );                }            glEnd();        }        void update(){            if(cx+r>=bottom_right.x){ //right wall bounce                direction.x = -1;            }            if(cx-r<=bottom_left.x){ //left wall bounce                direction.x = 1;            }            if(cy+r>=top_right.y-top_gap.y){ //top wall bounce                direction.y = -1;            }            if(cy-r<=bottom_right.y){ //bottom wall bounce                cstate = state.over;            }            float angle_difference = 0;            if(cy<bar.position_top){ //side bar bounce                if(cx>=bar.position_left-r && cx<=bar.position_left){ //left                    direction.x = -1;                }else if(cx<=bar.position_right+r && cx>=bar.position_right){ //right                    direction.x = 1;                }            }else if(cy<=bar.position_top+r && cy>=bar.position_top){                if(cx+r>=bar.position_left && cx-r<=bar.position_right){ //top bar bounce                    direction.y = 1;                    updateScore();                    if(cx+r<(bar.position_left+(bar.bar_size.x/2))){ //left side bar bounce                        if(direction.x==1){                            direction.x = -1;                        }                        angle_difference = (((bar.position_left+(bar.bar_size.x/2))-cx+r)/5);                        if(cx+r<bar.position_left+((bar.bar_size.x/4))){ //1st part                            if(angle-angle_difference>=10){                                angle -= angle_difference;                            }else{                                angle = 10;                            }                        }else{ //2nd part                            if(angle+angle_difference<90){                                angle += angle_difference;                            }else{                                angle = 90;                            }                        }                    }else{ //right side bar bounce                        if(direction.x==-1){                            direction.x = 1;                        }                        angle_difference = (((cx-r)-(bar.position_left+(bar.bar_size.x/2)))/5);                        if(cx+r<bar.position_left+((bar.bar_size.x/4)*3)){//3rd part                            if(angle+angle_difference<90){                                angle += angle_difference;                            }else{                                angle = 90;                            }                        }else{ //4th part                            if(angle-angle_difference>=10){                                angle -= angle_difference;                            }else{                                angle = 10;                            }                        }                    }                }            }            float theta = (angle*PI)/180;            cx += speed*cos(theta)*direction.x;            cy += speed*sin(theta)*direction.y;        }        void update(int x){            float new_left = x-(bar.bar_size.x/2);            float new_right = x+(bar.bar_size.x/2);            if(new_left>=bottom_left.x && new_right<=bottom_right.x){                cx = x;            }        }};Ball ball;void initialize(){    if(cstate == state.start){        time = 0;        level = 1;        score = 0;        getHighScore();    }    bar = Bar(200,20);    ball = Ball(8);}void drawTopGap(){    glBegin(GL_POLYGON);        glColor4f(top_gap_color.r,top_gap_color.g,top_gap_color.b,top_gap_color.a);        glVertex2f(top_left.x, top_left.y-top_gap.y);        glVertex2f(top_right.x, top_right.y-top_gap.y);        glVertex2f(top_right.x, top_right.y);        glVertex2f(top_left.x, top_left.y);    glEnd();}void drawText(){    glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);    glRasterPos2f(top_left.x+20, top_left.y-(top_gap.y/2)-12);    char buf[300], *p;    p = buf;    sprintf(buf, "High Score: %d",high_score);    do glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, *p); while(*(++p));    glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);    glRasterPos2f(top_left.x+320, top_left.y-(top_gap.y/2)-12);    p = buf;    sprintf(buf, "Time: %.2f",time);    do glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, *p); while(*(++p));    glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);    glRasterPos2f(top_left.x+600, top_left.y-(top_gap.y/2)-12);    p = buf;    sprintf(buf, "Score: %d",score);    do glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, *p); while(*(++p));    glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);    glRasterPos2f(top_left.x+900, top_left.y-(top_gap.y/2)-12);    p = buf;    sprintf(buf, "Level: %d",level);    do glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, *p); while(*(++p));}void drawState(){    if(cstate!=state.play && cstate!=state.running){        glEnable(GL_BLEND);        glColor4f(state_background_color.r,state_background_color.b,state_background_color.g,state_background_color.a);        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);        glBegin(GL_POLYGON);            glVertex3f(bottom_left.x, bottom_left.y,0);            glVertex3f(bottom_right.x, bottom_right.y,0);            glVertex3f(top_right.x, top_right.y-top_gap.y,0);            glVertex3f(top_left.x, top_left.y-top_gap.y,0);        glEnd();        glDisable(GL_BLEND);        char buf[300], *p;        if(cstate==state.start){            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "START GAME");            glTranslatef((top_right.x/2)-210, (top_left.y/2)-60, 0);            glScalef(0.5, 0.5, 0.5);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));        }else if(cstate==state.pause){            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "RESUME");            glTranslatef((top_right.x/2)-125, (top_left.y/2)-60, 0);            glScalef(0.5, 0.5, 0.5);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));        }else if(cstate==state.over){            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "GAME OVER");            glTranslatef((top_right.x/2)-200, (top_left.y/2)-25, 0);            glScalef(0.5, 0.5, 0.5);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "Play Again");            glTranslatef(-500, -150, 0);            glScalef(0.4, 0.4, 0.4);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));            if(score>high_score){                glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);                p = buf;                sprintf(buf, "New High Score: %d",score);                glTranslatef(-900, -250, 0);                glScalef(0.7, 0.7, 0.7);                do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));                setHighScore();            }        }else if(cstate==state.level){            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "New Level: %d",level);            glTranslatef((top_right.x/2)-200, (top_left.y/2)-60, 0);            glScalef(0.5, 0.5, 0.5);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));        }else if(cstate==state.complete){            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "GAME COMPLETE");            glTranslatef((top_right.x/2)-275, (top_left.y/2)-25, 0);            glScalef(0.5, 0.5, 0.5);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "Play Again");            glTranslatef(-670, -150, 0);            glScalef(0.4, 0.4, 0.4);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));            if(score>high_score){                glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);                p = buf;                sprintf(buf, "New High Score: %d",score);                glTranslatef(-900, -250, 0);                glScalef(0.7, 0.7, 0.7);                do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));                setHighScore();            }        }    }}void display(){    glClear(GL_COLOR_BUFFER_BIT);    glLoadIdentity();    drawTopGap();    drawText();    bar.draw();    ball.draw();    drawState();    glutSwapBuffers();}void updateTime(int){    glutTimerFunc(1000,updateTime,1);    if(cstate==state.running){        time += 0.01;        int td = (time-(int)time)*100;        if(td==59){            time++;            time-=0.59;        }    }}void timer(int){    glutPostRedisplay();    glutTimerFunc(displayRate,timer,0);    if(cstate==state.running){        ball.update();    }}void handleMouse(int x, int y) {	if(cstate==state.play){        bar.update(x);        ball.update(x);	}else if(cstate==state.running){        bar.update(x);	}	glutPostRedisplay();}void handleMouse(int button, int sstate, int x, int y){	if(button == GLUT_LEFT_BUTTON && sstate == GLUT_DOWN){        if(cstate==state.start){            cstate = state.play;        }else if(cstate==state.play){            cstate = state.running;        }else if(cstate==state.running){            cstate = state.pause;        }else if(cstate==state.pause){            cstate = state.running;        }else if(cstate==state.over){            cstate = state.start;            initialize();        }else if(cstate==state.level){            cstate = state.play;            initialize();        }else if(cstate==state.complete){            cstate = state.start;            initialize();        }	}else if(button == GLUT_RIGHT_BUTTON && sstate == GLUT_DOWN){        updateLevel();	}	glutPostRedisplay();}void reshape(int w,int h){    glViewport(0,0,(GLsizei)w,(GLsizei)h);    glMatrixMode(GL_PROJECTION);    glLoadIdentity();    gluOrtho2D(bottom_left.x, top_right.x, bottom_left.y, top_right.y);    glMatrixMode(GL_MODELVIEW);}int main(int argc, char** argv){    glutInit(&argc, argv);    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);    glutInitWindowSize(top_right.x, top_right.y);    glutInitWindowPosition(100, 150);    glutCreateWindow("Breakout Game");    initialize();    glutDisplayFunc(display);    glutReshapeFunc(reshape);    glutPassiveMotionFunc(handleMouse);    glutMouseFunc(handleMouse);    glClearColor(background_color.r, background_color.g, background_color.b, background_color.a); //white    glutTimerFunc(0,timer,0);    glutTimerFunc(0,updateTime,1);    glutMainLoop();    return 0;}
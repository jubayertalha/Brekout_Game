#include <windows.h>#include <GL/glut.h>#include <iostream>#include <math.h>#include <string>#include <fstream>#include <vector>using namespace std;struct Point{ float x; float y;};Point top_left = {.x=0, .y=600};Point top_right = {.x=1000, .y=600};Point bottom_left = {.x=0, .y=0};Point bottom_right = {.x=1000, .y=0};Point top_gap = {.x=0, .y=70};Point bottom_gap = {.x=0, .y=10};struct State{ int start; int play; int running; int pause; int over; int level; int complete;};State state = {.start=1,.play=2,.running=3,.pause=4,.over=5,.level=6,.complete=7};int cstate = state.start;struct Color{float r;float g;float b;float a;};Color background_color = {.r=1,.g=1,.b=1,.a=1};Color top_gap_color = {.r=1,.g=0,.b=0,.a=1};Color top_text_color = {.r=1,.g=1,.b=1,.a=1};Color state_background_color = {.r=0,.g=0,.b=0,.a=0.9};Color color_red = {.r=1,.g=0,.b=0,.a=1};Color color_green = {.r=0,.g=1,.b=0,.a=1};Color color_blue = {.r=0,.g=0,.b=1,.a=1};int high_score;float time;int level;int score;int speedd;float displayRate = 1000/60;const double PI = atan(1) * 4;int high_level = 10;void updateScore(int i){    score = score + i + (1/time);}void getHighScore(){    ifstream inFile;    inFile.open("high_score.txt");    if(inFile){        inFile>>high_score;    }else{        high_score = 0;    }    inFile.close();}void setHighScore(){    ofstream outFile;    outFile.open("high_score.txt");    outFile<<score<<endl;    outFile.close();}void updateLevel(){    if(level<high_level){        level++;        cstate = state.level;    }else{        cstate = state.complete;    }}class Brick{    public:        Point barick_size;        float position_left;        float position_right;        float position_bottom;        float position_top;        int life;        Color color;        Brick(){};        Brick(Point s,float l,float r,float b,float t,Color c){            barick_size = s;            position_left = l;            position_right = r;            position_bottom = b;            position_top = t;            life = ceil(level/2.0f);            color = c;        }        void draw(){            glEnable(GL_BLEND);            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);            glBegin(GL_POLYGON);                glVertex2f(position_left, position_bottom);                glColor4f(color.r,color.g,color.b,color.a);                glVertex2f(position_right, position_bottom);                glVertex2f(position_right, position_top);                glColor4f(0,0,0,color.a);                glVertex2f(position_left, position_top);                glShadeModel(GL_SMOOTH);            glEnd();            glDisable(GL_BLEND);        }};vector<Brick> bricks;template <typename Iterator>void updateBrick(Iterator brick){    updateScore(speedd);    brick->life--;    brick->color.a = brick->color.a-0.15;    if(brick->life==0){        bricks.erase(brick);    }    if(bricks.empty()){        updateLevel();    }}class Bar{    public:        Point bar_size;        float position_left;        float position_right;        float position_bottom;        float position_top;        Color color = {.r=1,.g=0,.b=0,.a=1};        Bar(){};        Bar(int x,int y){            bar_size.x = x;            bar_size.y = y;            position_left = (bottom_right.x/2)-(bar_size.x/2);            position_right = position_left+bar_size.x;            position_bottom = bottom_left.y+bottom_gap.y;            position_top = bottom_left.y+bottom_gap.y+bar_size.y;        }        void draw(){            glBegin(GL_POLYGON);                glShadeModel(GL_SMOOTH);                glColor4f(color.r,color.g,color.b,color.a);                glVertex2f(position_left, position_bottom);                glVertex2f(position_right, position_bottom);                glColor4f(0,0,1,color.a);                glVertex2f(position_right, position_top);                glVertex2f(position_left, position_top);            glEnd();        }        void update(int x){            float new_left = x-(bar_size.x/2);            float new_right = x+(bar_size.x/2);            if(new_left>=bottom_left.x && new_right<=bottom_right.x){                position_left = new_left;                position_right = new_right;            }        }};Bar bar;class Ball{    public:        float cx;        float cy;        float r;        float speed;        float angle;        Point direction;        Color color = {.r=1,.g=0,.b=0,.a=1};        Ball(){};        Ball(int rr){            cx = 500;            cy = bottom_gap.y+bar.bar_size.y+rr;            r = rr;            speed = 5;            angle = 40;            direction.x = -1;            direction.y = 1;        }        void draw(){            int triangleAmount = 100;            glBegin(GL_TRIANGLE_FAN);                glColor3d(211,211,211);                glVertex2f(cx, cy);                for(int i = 0; i <= triangleAmount;i++){                    float theta = i *  2 * PI / triangleAmount;                    glVertex2f(                        cx + (r * cos(theta)),                        cy + (r * sin(theta))                    );                }            glEnd();        }        void updateSpeed(){            if(speed<=7.4){                speed+=0.05;            }            speedd = speed;        }        void update(){            if(cx+r>=bottom_right.x){ //right wall bounce                direction.x = -1;            }            if(cx-r<=bottom_left.x){ //left wall bounce                direction.x = 1;            }            if(cy+r>=top_right.y-top_gap.y){ //top wall bounce                direction.y = -1;            }            if(cy-r<=bottom_right.y){ //bottom wall bounce                cstate = state.over;                direction.y = 1;            }            float angle_difference = 0;            if(cy<bar.position_top){ //side bar bounce                if(cx>=bar.position_left-r && cx<=bar.position_left){ //left                    direction.x = -1;                }else if(cx<=bar.position_right+r && cx>=bar.position_right){ //right                    direction.x = 1;                }            }else if(cy<=bar.position_top+r && cy>=bar.position_top){                if(cx+r>=bar.position_left && cx-r<=bar.position_right){ //top bar bounce                    direction.y = 1;                    if(cx+r<(bar.position_left+(bar.bar_size.x/2))){ //left side bar bounce                        if(direction.x==1){                            direction.x = -1;                        }                        angle_difference = (((bar.position_left+(bar.bar_size.x/2))-cx+r)/5);                        if(cx+r<bar.position_left+((bar.bar_size.x/4))){ //1st part                            if(angle-angle_difference>=10){                                angle -= angle_difference;                            }else{                                angle = 10;                            }                        }else{ //2nd part                            if(angle+angle_difference<90){                                angle += angle_difference;                            }else{                                angle = 90;                            }                        }                    }else{ //right side bar bounce                        if(direction.x==-1){                            direction.x = 1;                        }                        angle_difference = (((cx-r)-(bar.position_left+(bar.bar_size.x/2)))/5);                        if(cx+r<bar.position_left+((bar.bar_size.x/4)*3)){//3rd part                            if(angle+angle_difference<90){                                angle += angle_difference;                            }else{                                angle = 90;                            }                        }else{ //4th part                            if(angle-angle_difference>=10){                                angle -= angle_difference;                            }else{                                angle = 10;                            }                        }                    }                }            }            //brick bounce            for(vector<Brick>::iterator brick = bricks.begin(); brick != bricks.end(); brick++){                float left = brick->position_left;                float right = brick->position_right;                float bottom = brick->position_bottom;                float top = brick->position_top;                if(cx>=left&&cx<=right){                    if(cy+r>=bottom&&cy<=bottom&&direction.y==1){ //bottom                        direction.y = -1;                        updateBrick(brick);                        updateSpeed();                        break;                    }else if(cy>=top&&cy-r<=top&&direction.y==-1){ //top                        direction.y = 1;                        updateBrick(brick);                        updateSpeed();                        break;                    }                }else if(cy>=bottom&&cy<=top){                    if(cx<=left&&cx+r>=left&&direction.x==1){ //left                        direction.x = -1;                        updateBrick(brick);                        updateSpeed();                        break;                    }else if(cx-r<=right&&cx>=right&&direction.x==-1){ //right                        direction.x = 1;                        updateBrick(brick);                        updateSpeed();                        break;                    }                }                //corner                if(direction.x==1&&direction.y==1){ //left-bottom                    if((cx<=left&&cx+r>=left)&&(cy+r>=bottom&&cy<=bottom)){                        direction.x = -1;                        direction.y = -1;                        updateBrick(brick);                        updateSpeed();                        break;                    }                }else if(direction.x==1&&direction.y==-1){ //left-top                    if((cx<=left&&cx+r>=left)&&(cy>=top&&cy-r<=top)){                        direction.x = -1;                        direction.y = 1;                        updateBrick(brick);                        updateSpeed();                        break;                    }                }else if(direction.x==-1&&direction.y==-1){ //right-top                    if((cx-r<=right&&cx>=right)&&(cy>=top&&cy-r<=top)){                        direction.x = 1;                        direction.y = 1;                        updateBrick(brick);                        updateSpeed();                        break;                    }                }else if(direction.x==-1&&direction.y==1){ //right-bottom                   if((cx-r<=right&&cx>=right)&&(cy+r>=bottom&&cy<=bottom)){                        direction.x = 1;                        direction.y = -1;                        updateBrick(brick);                        updateSpeed();                        break;                    }                }            }            float theta = (angle*PI)/180;            cx += speed*cos(theta)*direction.x;            cy += speed*sin(theta)*direction.y;        }        void update(int x){            float new_left = x-(bar.bar_size.x/2);            float new_right = x+(bar.bar_size.x/2);            if(new_left>=bottom_left.x && new_right<=bottom_right.x){                cx = x;            }        }};Ball ball;void initializeBricksOne(){    float old_left_most_position = top_left.x+top_gap.y;    float top_most_position = top_left.y-(top_gap.y*2);    float left_most_position;    float left_space = 5;    float bottom_space = 5;    int total_block = 4;    int total_row = 4;    int total_column = 3;    Color colors[4][3];    colors[0][0] = color_red; colors[0][1] = color_green; colors[0][2] = color_blue;    colors[1][0] = color_green; colors[1][1] = color_blue; colors[1][2] = color_blue;    colors[2][0] = color_blue; colors[2][1] = color_blue; colors[2][2] = color_green;    colors[3][0] = color_blue; colors[3][1] = color_green; colors[3][2] = color_red;    Point brick_size = {.x=50,.y=25};    float middle_space = ((top_right.x-(top_gap.y*2))-(((brick_size.x*total_column)+(left_space*(total_column-1)))*total_block))/(total_block-1);    for(int i=0;i<total_block;i++){        left_most_position = old_left_most_position + ((((brick_size.x+left_space)*(total_column-1))+brick_size.x+middle_space)*i);        for(int j=0;j<total_column;j++){            for(int k=0;k<total_row;k++){                float position_left = left_most_position+((brick_size.x+left_space)*j);                float position_right = position_left+brick_size.x;                float position_top = top_most_position-((brick_size.y+bottom_space)*k);                float position_bottom = position_top-brick_size.y;                Brick brick = Brick(brick_size,position_left,position_right,position_bottom,position_top,colors[k][j]);                bricks.push_back(brick);            }        }    }}void initializeBricksTwo(){    float old_left_most_position = top_left.x+top_gap.y;    float top_most_position = top_left.y-(top_gap.y*2);    float left_most_position;    float left_space = 5;    float bottom_space = 5;    int total_block = 6;    int total_row = 6;    int total_column = 2;    Color colors[6][2];    colors[0][0] = color_red; colors[0][1] = color_red;    colors[1][0] = color_green; colors[1][1] = color_green;    colors[2][0] = color_blue; colors[2][1] = color_blue;    colors[3][0] = color_blue; colors[3][1] = color_blue;    colors[4][0] = color_green; colors[4][1] = color_green;    colors[5][0] = color_red; colors[5][1] = color_red;    Point brick_size = {.x=50,.y=25};    float middle_space = ((top_right.x-(top_gap.y*2))-(((brick_size.x*total_column)+(left_space*(total_column-1)))*total_block))/(total_block-1);    for(int i=0;i<total_block;i++){        left_most_position = old_left_most_position + ((((brick_size.x+left_space)*(total_column-1))+brick_size.x+middle_space)*i);        for(int j=0;j<total_column;j++){            for(int k=0;k<total_row;k++){                float position_left = left_most_position+((brick_size.x+left_space)*j);                float position_right = position_left+brick_size.x;                float position_top = top_most_position-((brick_size.y+bottom_space)*k);                float position_bottom = position_top-brick_size.y;                Brick brick = Brick(brick_size,position_left,position_right,position_bottom,position_top,colors[k][j]);                bricks.push_back(brick);            }        }    }}void initialize(){    if(cstate == state.start){        time = 0;        level = 1;        score = 0;        speedd = 5;        getHighScore();    }    bricks.clear();    if(level%2==1){        initializeBricksOne();    }else{        initializeBricksTwo();    }    bar = Bar(200,20);    ball = Ball(8);}void drawBricks(){    for(vector<Brick>::iterator brick = bricks.begin(); brick != bricks.end(); brick++){        brick->draw();    }}void drawTopGap(){    glBegin(GL_POLYGON);        glColor4f(top_gap_color.r,top_gap_color.g,top_gap_color.b,top_gap_color.a);        glVertex2f(top_left.x, top_left.y-top_gap.y);        glColor4f(0,top_gap_color.g,top_gap_color.b,top_gap_color.a);        glVertex2f(top_right.x, top_right.y-top_gap.y);        glVertex2f(top_right.x, top_right.y);        glVertex2f(top_left.x, top_left.y);    glEnd();}void drawText(){    glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);    glRasterPos2f(top_left.x+20, top_left.y-(top_gap.y/2)-12);    char buf[300], *p;    p = buf;    sprintf(buf, "High Score: %d",high_score);    do glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, *p); while(*(++p));    glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);    glRasterPos2f(top_left.x+320, top_left.y-(top_gap.y/2)-12);    p = buf;    sprintf(buf, "Time: %.2f",time);    do glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, *p); while(*(++p));    glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);    glRasterPos2f(top_left.x+600, top_left.y-(top_gap.y/2)-12);    p = buf;    sprintf(buf, "Score: %d",score);    do glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, *p); while(*(++p));    glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);    glRasterPos2f(top_left.x+900, top_left.y-(top_gap.y/2)-12);    p = buf;    sprintf(buf, "Level: %d",level);    do glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, *p); while(*(++p));}void drawState(){    if(cstate!=state.play && cstate!=state.running){        glEnable(GL_BLEND);        glColor4f(state_background_color.r,state_background_color.b,state_background_color.g,state_background_color.a);        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);        glBegin(GL_POLYGON);            glVertex3f(bottom_left.x, bottom_left.y,0);            glVertex3f(bottom_right.x, bottom_right.y,0);            glVertex3f(top_right.x, top_right.y-top_gap.y,0);            glVertex3f(top_left.x, top_left.y-top_gap.y,0);        glEnd();        glDisable(GL_BLEND);        char buf[300], *p;        if(cstate==state.start){            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "START GAME");            glTranslatef((top_right.x/2)-210, (top_left.y/2)-60, 0);            glScalef(0.5, 0.5, 0.5);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));        }else if(cstate==state.pause){            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "RESUME");            glTranslatef((top_right.x/2)-125, (top_left.y/2)-60, 0);            glScalef(0.5, 0.5, 0.5);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));        }else if(cstate==state.over){            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "GAME OVER");            glTranslatef((top_right.x/2)-200, (top_left.y/2)-25, 0);            glScalef(0.5, 0.5, 0.5);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "Play Again");            glTranslatef(-500, -150, 0);            glScalef(0.4, 0.4, 0.4);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));            if(score>high_score){                glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);                p = buf;                sprintf(buf, "New High Score: %d",score);                glTranslatef(-900, -250, 0);                glScalef(0.7, 0.7, 0.7);                do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));                setHighScore();            }        }else if(cstate==state.level){            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "New Level: %d",level);            glTranslatef((top_right.x/2)-200, (top_left.y/2)-60, 0);            glScalef(0.5, 0.5, 0.5);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));        }else if(cstate==state.complete){            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "GAME COMPLETE");            glTranslatef((top_right.x/2)-275, (top_left.y/2)-25, 0);            glScalef(0.5, 0.5, 0.5);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));            glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);            p = buf;            sprintf(buf, "Play Again");            glTranslatef(-670, -150, 0);            glScalef(0.4, 0.4, 0.4);            do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));            if(score>high_score){                glColor4f(top_text_color.r,top_text_color.g,top_text_color.b,top_text_color.a);                p = buf;                sprintf(buf, "New High Score: %d",score);                glTranslatef(-900, -250, 0);                glScalef(0.7, 0.7, 0.7);                do glutStrokeCharacter(GLUT_STROKE_ROMAN, *p); while(*(++p));                setHighScore();            }        }    }}void drawBG(){    glBegin(GL_POLYGON);        glColor4f(top_gap_color.r,top_gap_color.g,top_gap_color.b,top_gap_color.a);        glVertex2f(top_left.x, top_left.y);        glColor4f(0,top_gap_color.g,top_gap_color.b,top_gap_color.a);        glVertex2f(top_right.x, top_right.y);        glVertex2f(bottom_right.x, bottom_right.y);        glVertex2f(bottom_left.x, bottom_left.y);    glEnd();}void display(){    glClear(GL_COLOR_BUFFER_BIT);    glLoadIdentity();    drawBG();    drawTopGap();    drawText();    bar.draw();    ball.draw();    drawBricks();    drawState();    glutSwapBuffers();}void updateTime(int){    glutTimerFunc(1000,updateTime,1);    if(cstate==state.running){        time += 0.01;        int td = (time-(int)time)*100;        if(td==59){            time++;            time-=0.59;        }    }}void timer(int){    glutPostRedisplay();    glutTimerFunc(displayRate,timer,0);    if(cstate==state.running){        ball.update();    }}void handleMouse(int x, int y) {	if(cstate==state.play){        bar.update(x);        ball.update(x);	}else if(cstate==state.running){        bar.update(x);	}	glutPostRedisplay();}void handleMouse(int button, int sstate, int x, int y){	if(button == GLUT_LEFT_BUTTON && sstate == GLUT_DOWN){        if(cstate==state.start){            cstate = state.play;        }else if(cstate==state.play){            cstate = state.running;        }else if(cstate==state.running){            cstate = state.pause;        }else if(cstate==state.pause){            cstate = state.running;        }else if(cstate==state.over){            cstate = state.start;            initialize();        }else if(cstate==state.level){            cstate = state.play;            initialize();        }else if(cstate==state.complete){            cstate = state.start;            initialize();        }	}else if(button == GLUT_RIGHT_BUTTON && sstate == GLUT_DOWN){        updateLevel();	}	glutPostRedisplay();}void reshape(int w,int h){    glViewport(0,0,(GLsizei)w,(GLsizei)h);    glMatrixMode(GL_PROJECTION);    glLoadIdentity();    gluOrtho2D(bottom_left.x, top_right.x, bottom_left.y, top_right.y);    glMatrixMode(GL_MODELVIEW);}int main(int argc, char** argv){    glutInit(&argc, argv);    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);    glutInitWindowSize(top_right.x, top_right.y);    glutInitWindowPosition(100, 150);    glutCreateWindow("Breakout Game");    initialize();    glutDisplayFunc(display);    glutReshapeFunc(reshape);    glutPassiveMotionFunc(handleMouse);    glutMouseFunc(handleMouse);    glClearColor(background_color.r, background_color.g, background_color.b, background_color.a); //white    glutTimerFunc(0,timer,0);    glutTimerFunc(0,updateTime,1);    glutMainLoop();    return 0;}